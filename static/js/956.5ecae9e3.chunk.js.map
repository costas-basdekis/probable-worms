{"version":3,"file":"static/js/956.5ecae9e3.chunk.js","mappings":"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","sources":["worms/RollResult.tsx","worms/DiceRoll.tsx","worms/Chest.tsx","worms/Results.tsx","worms/Evaluation.tsx","worms/RolledStateEvaluator.tsx","worms/UnrolledStateEvaluator.tsx","worms/StateEvaluator.tsx","worms/EvaluationCache.tsx","worms/UnrolledState.tsx","worms/RolledState.tsx","EvaluationCacheCache.tsx","worker.tsx","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export type RollResult = 1 | 2 | 3 | 4 | 5 | \"W\";\nexport const Worm: RollResult = \"W\";\nexport const rollResults: RollResult[] = [1, 2, 3, 4, 5, Worm];\nexport const ValueMap: Map<RollResult, number> = new Map([\n  [1, 1],\n  [2, 2],\n  [3, 3],\n  [4, 4],\n  [5, 5],\n  [Worm, 5],\n] as [RollResult, number][]);\n","import _ from \"underscore\";\nimport {RollResult, rollResults, ValueMap} from \"./RollResult\";\n\nexport class DiceRoll {\n  counts: Map<RollResult, number>;\n  key: string;\n  total: number;\n\n  static fromDice(dice: RollResult[]): DiceRoll {\n    return new DiceRoll(\n      Object.values(_.groupBy(dice)).map((group) => [group[0], group.length])\n    );\n  }\n\n  static random(remainingDiceCount: number): DiceRoll {\n    return this.fromDice(_.range(remainingDiceCount).map(() => rollResults[_.random(0, rollResults.length - 1)]));\n  }\n\n  constructor(items?: Iterable<readonly [RollResult, number]>) {\n    this.counts = new Map(items as Iterable<readonly [RollResult, number]>);\n    this.key = JSON.stringify(Array.from(this.counts.entries()).sort());\n    this.total = Array.from(this.counts.entries()).reduce(\n      (total, [roll, count]) => total + ValueMap.get(roll)! * count,\n      0\n    );\n  }\n\n  equals(other: DiceRoll): boolean {\n    if (this === other) {\n      return true;\n    }\n    return this.key === other.key;\n  }\n\n  adding(roll: RollResult, count: number): DiceRoll {\n    return new DiceRoll([\n      ...Array.from(this.counts.entries()),\n      [roll, count] as [RollResult, number],\n    ]);\n  }\n\n  copy(): DiceRoll {\n    return new DiceRoll(this.counts.entries());\n  }\n\n  get(key: RollResult): number {\n    return this.counts.get(key) ?? 0;\n  }\n\n  has(key: RollResult): boolean {\n    return this.counts.has(key);\n  }\n\n  keys(): Iterable<RollResult> {\n    return this.counts.keys();\n  }\n\n  entries(): Iterable<[RollResult, number]> {\n    return this.counts.entries();\n  }\n\n  get count(): number {\n    return this.counts.size;\n  }\n\n  get diceCount(): number {\n    return Array.from(this.counts.values()).reduce((total, current) => total + current, 0);\n  }\n\n  get dice(): RollResult[] {\n    return Array.from(this.counts.entries()).map(([roll, count]) => _.range(count).map(() => roll)).flat().sort((lhs, rhs) => {\n      return rollResults.indexOf(lhs) - rollResults.indexOf(rhs)!;\n    });\n  }\n\n  replacing(roll: RollResult, count: number): DiceRoll {\n    return this.copy().replace(roll, count);\n  }\n\n  replace(roll: RollResult, count: number): DiceRoll {\n    if (count) {\n      this.counts.set(roll, count);\n    } else if (this.has(roll)) {\n      this.counts.delete(roll);\n    }\n    return this;\n  }\n\n  limitToCount(diceCount: number): DiceRoll {\n    if (diceCount <= this.diceCount) {\n      return this;\n    }\n    const diceRoll = new DiceRoll();\n    let remainingDiceCount = diceCount;\n    for (const roll of rollResults) {\n      const rollCount = Math.min(remainingDiceCount, this.get(roll));\n      diceRoll.counts.set(roll, rollCount);\n      remainingDiceCount -= rollCount;\n    }\n    return diceRoll;\n  }\n\n  getFaces(): RollResult[] {\n    return rollResults.filter(face => this.has(face));\n  }\n\n  getOppositeFaces(): RollResult[] {\n    return rollResults.filter(face => !this.has(face));\n  }\n\n  limitToFaces(faces: RollResult[]): DiceRoll {\n    if (!faces.some(face => this.has(face))) {\n      return this;\n    }\n    const diceRoll = new DiceRoll();\n    for (const face of faces) {\n      diceRoll.replace(face, this.get(face));\n    }\n    return diceRoll;\n  }\n\n  static getNextRolls(diceCount: number): {diceRoll: DiceRoll, count: number}[] {\n    const diceRollInfoByKey: Map<string, {diceRoll: DiceRoll, count: number}> = new Map();\n\n    for (const diceRoll of DiceRoll.iterateDiceRolls(diceCount)) {\n      if (!diceRollInfoByKey.has(diceRoll.key)) {\n        diceRollInfoByKey.set(diceRoll.key, { diceRoll, count: 0 });\n      }\n      diceRollInfoByKey.get(diceRoll.key)!.count += 1;\n    }\n\n    return Array.from(diceRollInfoByKey.values());\n  }\n\n  static *iterateDiceRolls(count: number): Iterable<DiceRoll> {\n    if (!count) {\n      return;\n    }\n    function *addLayer<T>(lists: Iterable<T[]>, layer: T[]): Iterable<T[]> {\n      for (const list of lists) {\n        for (const newItem of layer) {\n          yield [...list, newItem];\n        }\n      }\n    }\n    let items: Iterable<RollResult[]> = [[]];\n    for (const _1 in _.range(count)) {\n      items = addLayer(items, rollResults);\n    }\n    for (const item of items) {\n      yield DiceRoll.fromDice(item);\n    }\n  }\n}\n","import { DiceRoll } from \"./DiceRoll\";\nimport { RollResult, Worm } from \"./RollResult\";\n\nexport class Chest {\n  diceCounts: DiceRoll;\n  hasWorms: boolean;\n\n  static initial(): Chest {\n    return new Chest(new DiceRoll(), false);\n  }\n\n  static fromDiceRoll(diceRoll: DiceRoll): Chest {\n    return new Chest(new DiceRoll(diceRoll.entries()), diceRoll.has(Worm));\n  }\n\n  static fromDice(dice: RollResult[]): Chest {\n    return this.fromDiceRoll(DiceRoll.fromDice(dice));\n  }\n\n  constructor(diceCounts: DiceRoll, hasWorms: boolean) {\n    this.diceCounts = diceCounts;\n    this.hasWorms = hasWorms;\n  }\n\n  equals(other: Chest): boolean {\n    if (this === other) {\n      return true;\n    }\n    return (\n      this.hasWorms === other.hasWorms\n      && this.diceCounts.equals(other.diceCounts)\n    );\n  }\n\n  get total(): number {\n    return this.diceCounts.total;\n  }\n\n  get diceCount(): number {\n    return this.diceCounts.diceCount;\n  }\n\n  get dice(): RollResult[] {\n    return this.diceCounts.dice;\n  }\n\n  get key(): string {\n    return this.diceCounts.key;\n  }\n\n  uniqueDice(): RollResult[] {\n    return Array.from(this.diceCounts.keys()).sort();\n  }\n\n  canAdd(roll: RollResult): boolean {\n    return !this.diceCounts.has(roll);\n  }\n\n  add(roll: RollResult, diceCount: number): Chest {\n    if (!this.canAdd(roll)) {\n      throw new Error(\"Cannot add existing dice to chest\");\n    }\n    return new Chest(\n      this.diceCounts.adding(roll, diceCount), \n      this.hasWorms || roll === Worm,\n    );\n  }\n\n  get(roll: RollResult): number {\n    return this.diceCounts.get(roll);\n  }\n\n  replacing(roll: RollResult, count: number): Chest {\n    return Chest.fromDiceRoll(this.diceCounts.replacing(roll, count));\n  }\n}\n","import _ from \"underscore\";\n\nexport type SerialisedResults = [number, number][];\nexport type CompressedSerialisedResults = [number, number, number][];\nexport interface SerialisationOptions {\n  compressed?: boolean,\n  rounded?: boolean,\n  sparse?: boolean,\n}\n\nexport class Results {\n  counts: Map<number, number>;\n\n  static deserialise(serialised: SerialisedResults | CompressedSerialisedResults, options: SerialisationOptions): Results {\n    if (options.compressed) {\n      const expandedTriples: [number, number][][] = (serialised as CompressedSerialisedResults).map(\n        ([min, max, ratio]) => _.range(min, max + 1).map(\n          (total) => [total, ratio]));\n      serialised = expandedTriples.flat();\n    }\n    if (options.rounded) {\n      serialised = serialised.map(([key, value]) => [key, (value === -1 ? 1000 : value) / 1000])\n    }\n    return new Results(serialised as SerialisedResults);\n  }\n\n  constructor(items?: Iterable<readonly [number, number]>) {\n    this.counts = new Map(items as Iterable<readonly [number, number]>);\n  }\n\n  has(key: number): boolean {\n    return this.counts.has(key);\n  }\n\n  get(key: number): number | undefined {\n    return this.counts.get(key);\n  }\n\n  set(key: number, value: number): this {\n    this.counts.set(key, value);\n    return this;\n  }\n\n  keys(): Iterable<number> {\n    return this.counts.keys();\n  }\n\n  entries(): Iterable<[number, number]> {\n    return this.counts.entries();\n  }\n\n  mergeWith(other: Results): this {\n    for (const [total, count] of other.entries()) {\n      this.set(total, (this.get(total) || 0) + count);\n    }\n    return this;\n  }\n\n  add(result: number, count: number): void {\n    this.set(result, (this.get(result) || 0) + count);\n  }\n\n  get total(): number {\n    return Array.from(this.counts.values()).reduce(\n      (total, current) => total + current,\n      0\n    );\n  }\n\n  toFixed(): Results {\n    return new Results(\n      Array.from(this.entries()).map(([key, value]: [number, number]) => {\n        if (isNaN(parseFloat(value.toFixed(6)))) {\n          throw new Error(\n            `Value was not a number, it was a ${\n              value?.constructor?.name || value\n            }: ${value}`\n          );\n        }\n        return [key, parseFloat(value.toFixed(6))] as [number, number];\n      })\n    );\n  }\n\n  serialise(options: SerialisationOptions): SerialisedResults | CompressedSerialisedResults {\n    let serialised: SerialisedResults | CompressedSerialisedResults = Array.from(this.entries());\n    if (options.rounded) {\n      serialised = serialised.map(([total, ratio]) => {\n        const value = Math.round(ratio * 1000);\n        return [total, value === 1000 ? -1 : value];\n      });\n    }\n    if (options.compressed) {\n      serialised = serialised.sort(([lTotal], [rTotal]) => lTotal - rTotal).reduce((total, [rollTotal, ratio]): [number, number, number][] => {\n        const min = rollTotal, max = rollTotal;\n        if (!total.length) {\n          return [[min, max, ratio]];\n        }\n        const [lastMin, lastMax, lastRatio] = total[total.length - 1];\n        if (lastMax !== (max - 1) || lastRatio !== ratio) {\n          return [...total, [min, max, ratio]];\n        }\n        return [...total.slice(0, total.length - 1), [lastMin, max, lastRatio]];\n      }, [] as [number, number, number][]);\n    }\n    return serialised;\n  }\n}\n","import _ from \"underscore\";\n\nimport {CompressedSerialisedResults, Results, SerialisationOptions, SerialisedResults} from \"./Results\";\n\nexport interface SerialisedEvaluation {\n  minimumResultOccurrencesEntries: SerialisedResults,\n  exactResultOccurrencesEntries: SerialisedResults,\n  expectedValueOfAtLeastEntries: SerialisedResults,\n  expectedValue: number,\n}\n\nexport interface CompressedSerialisedEvaluation {\n  minimumResultOccurrencesEntries: CompressedSerialisedResults,\n  exactResultOccurrencesEntries: SerialisedResults,\n  expectedValueOfAtLeastEntries: CompressedSerialisedResults,\n  expectedValue: number,\n}\n\nexport class Evaluation {\n  minimumResultOccurrences: Results;\n  exactResultOccurrences: Results;\n  expectedValueOfAtLeast: Results;\n  expectedValue: number;\n\n  static combineOptions(options: Evaluation[]): Evaluation {\n    const combined = this.empty();\n    let maxExpectedValue = 0;\n    for (const evaluation of options) {\n      for (const [result, count] of evaluation.minimumResultOccurrences.entries()) {\n        combined.minimumResultOccurrences.set(result, Math.max(combined.minimumResultOccurrences.get(result) || 0, count));\n      }\n      for (const [result, count] of evaluation.exactResultOccurrences.entries()) {\n        combined.exactResultOccurrences.set(result, Math.max(combined.exactResultOccurrences.get(result) || 0, count));\n      }\n      for (const [result, expectedValue] of evaluation.expectedValueOfAtLeast.entries()) {\n        combined.expectedValueOfAtLeast.set(result, Math.max(combined.expectedValueOfAtLeast.get(result) || 0, expectedValue));\n      }\n      maxExpectedValue = Math.max(maxExpectedValue, evaluation.expectedValue);\n    }\n    combined.expectedValue = maxExpectedValue;\n    return combined;\n  }\n\n  static combineProbabilities(options: {evaluation: Evaluation, ratio: number}[]): Evaluation {\n    const combined = this.empty();\n    let expectedValue = 0;\n    for (const {evaluation, ratio: evaluationRatio} of options) {\n      for (const [result, ratio] of evaluation.minimumResultOccurrences.entries()) {\n        combined.minimumResultOccurrences.set(result, (combined.minimumResultOccurrences.get(result) || 0) + ratio * evaluationRatio);\n      }\n      for (const [result, ratio] of evaluation.exactResultOccurrences.entries()) {\n        combined.exactResultOccurrences.set(result, (combined.exactResultOccurrences.get(result) || 0) + ratio * evaluationRatio);\n      }\n      for (const [result, expectedValue] of evaluation.expectedValueOfAtLeast.entries()) {\n        combined.expectedValueOfAtLeast.set(result, (combined.expectedValueOfAtLeast.get(result) || 0) + expectedValue * evaluationRatio);\n      }\n      expectedValue += evaluation.expectedValue * evaluationRatio;\n    }\n    combined.expectedValue = expectedValue;\n    return combined;\n  }\n\n  static fromTotal(total: number): Evaluation {\n    const evaluation = this.empty();\n    for (const minTotal of _.range(1, total + 1)) {\n      evaluation.minimumResultOccurrences.set(minTotal, 1);\n      evaluation.expectedValueOfAtLeast.set(minTotal, total);\n    }\n    evaluation.exactResultOccurrences.set(total, 1);\n    evaluation.expectedValue = total;\n    return evaluation;\n  }\n\n  static empty(): Evaluation {\n    return new Evaluation(new Results(), new Results(), new Results(), 0);\n  }\n\n  static deserialise(serialised: SerialisedEvaluation | CompressedSerialisedEvaluation, options: SerialisationOptions): Evaluation {\n    return new Evaluation(\n      Results.deserialise(serialised.minimumResultOccurrencesEntries, options),\n      Results.deserialise(serialised.exactResultOccurrencesEntries, _.omit(options, \"compressed\")),\n      Results.deserialise(serialised.expectedValueOfAtLeastEntries, options),\n      serialised.expectedValue,\n    );\n  }\n\n  constructor(minimumResultOccurrences: Results, exactResultOccurrences: Results, expectedValueOfAtLeast: Results, expectedValue: number) {\n    this.minimumResultOccurrences = minimumResultOccurrences;\n    this.exactResultOccurrences = exactResultOccurrences;\n    this.expectedValueOfAtLeast = expectedValueOfAtLeast;\n    this.expectedValue = expectedValue;\n  }\n\n  toFixed(): Evaluation {\n    return new Evaluation(\n      this.minimumResultOccurrences.toFixed(),\n      this.exactResultOccurrences.toFixed(),\n      this.expectedValueOfAtLeast.toFixed(),\n      parseFloat(this.expectedValue.toFixed(6)),\n    );\n  }\n\n  serialise(options: SerialisationOptions): SerialisedEvaluation | CompressedSerialisedEvaluation {\n    let expectedValue = this.expectedValue;\n    if (options.rounded) {\n      expectedValue = parseInt(expectedValue.toFixed(1), 10);\n    }\n    return {\n      minimumResultOccurrencesEntries: this.minimumResultOccurrences.serialise(options) as SerialisedResults,\n      exactResultOccurrencesEntries: this.exactResultOccurrences.serialise(_.omit(options, \"compressed\")) as SerialisedResults,\n      expectedValueOfAtLeastEntries: this.expectedValueOfAtLeast.serialise(options) as SerialisedResults,\n      expectedValue,\n    };\n  }\n}\n","import {Evaluation} from \"./Evaluation\";\nimport {RolledState} from \"./RolledState\";\nimport {UnrolledState} from \"./UnrolledState\";\nimport {UnrolledStateEvaluator} from \"./UnrolledStateEvaluator\";\nimport {EvaluationCache} from \"./EvaluationCache\";\nimport {IStateEvaluator} from \"./IStateEvaluator\";\n\ninterface NextUnrolledState {\n  unrolledState: UnrolledState;\n  evaluator: UnrolledStateEvaluator | null;\n  evaluation: Evaluation | null;\n}\n\ninterface SearchOptions {\n  removeEvaluated?: boolean,\n  evaluationCache?: EvaluationCache,\n}\n\nexport class RolledStateEvaluator implements IStateEvaluator<RolledState> {\n  state: RolledState;\n  nextUnrolledStates: NextUnrolledState[];\n  evaluation: Evaluation | null = null;\n\n  static fromRolledState(rolledState: RolledState): RolledStateEvaluator {\n    const nextUnrolledStates = rolledState.getNextUnrolledStates();\n    return new RolledStateEvaluator(\n      rolledState,\n      nextUnrolledStates.map(unrolledState => ({unrolledState, evaluator: null, evaluation: null})),\n    );\n  }\n  static getRemainingDiceCountFromCacheKey(cacheKey: string): number | null {\n    if (cacheKey[0] !== \"R\") {\n      return null;\n    }\n    const [, diceStr] = cacheKey.split(\"d\");\n    const dice = diceStr.split(\",\").map(itemStr => parseInt(itemStr, 10));\n    return dice.reduce((total, current, index) => (index % 2 === 0) ? total : (total + current), 0);\n  }\n\n  constructor(rolledState: RolledState, nextUnrolledStates: NextUnrolledState[]) {\n    this.state = rolledState;\n    this.nextUnrolledStates = nextUnrolledStates;\n  }\n\n  get finished(): boolean {\n    return this.evaluation !== null;\n  }\n\n  processAll(options?: SearchOptions): this {\n    while (this.processOne(options)) {\n      //\n    }\n    return this;\n  }\n\n  processOne(options?: SearchOptions): boolean {\n    if (this.finished) {\n      return false;\n    }\n    if (this.nestedProcessOne(options)) {\n      return true;\n    }\n    this.evaluation = this.compileEvaluation();\n    return false;\n  }\n\n  nestedProcessOne(options?: SearchOptions): boolean {\n    const {removeEvaluated = false} = options ?? {};\n    if (this.finished) {\n      return false;\n    }\n    for (const nextUnrolledState of this.nextUnrolledStates) {\n      if (nextUnrolledState.evaluation) {\n        continue;\n      }\n      if (!nextUnrolledState.evaluator) {\n        nextUnrolledState.evaluator = UnrolledStateEvaluator.fromUnrolledState(nextUnrolledState.unrolledState, false);\n        if (this.useEvaluationCache(nextUnrolledState, options)) {\n          continue;\n        }\n      }\n      nextUnrolledState.evaluator.processOne(options);\n      if (nextUnrolledState.evaluator.evaluation) {\n        nextUnrolledState.evaluation = nextUnrolledState.evaluator.evaluation;\n        this.setEvaluationCache(nextUnrolledState, options);\n        if (removeEvaluated) {\n          nextUnrolledState.evaluator = null;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  useEvaluationCache(nextUnrolledState: NextUnrolledState, options?: SearchOptions): boolean {\n    if (!nextUnrolledState.evaluator) {\n      return false;\n    }\n    const {removeEvaluated = false, evaluationCache} = options ?? {};\n    const evaluation = evaluationCache?.get(nextUnrolledState.evaluator.getCacheKey());\n    if (evaluation) {\n      nextUnrolledState.evaluation = evaluation;\n      if (removeEvaluated) {\n        nextUnrolledState.evaluator = null;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  setEvaluationCache(nextUnrolledState: NextUnrolledState, options?: SearchOptions) {\n    if (!nextUnrolledState.evaluator || !nextUnrolledState.evaluation) {\n      return;\n    }\n    const {evaluationCache} = options ?? {};\n    if (evaluationCache) {\n      evaluationCache.set(nextUnrolledState.evaluator.getCacheKey(), nextUnrolledState.evaluation);\n    }\n  }\n\n  getCacheKey(): string {\n    return [\n      \"R\",\n      `t${this.state.unrolledState.chest.total}`,\n      `c${this.state.unrolledState.chest.uniqueDice().join(\",\")}`,\n      `d${this.state.diceRoll.key}`,\n    ].join(\"\").replaceAll(/[[\\]]/g, \"\");\n  }\n\n  compileEvaluation(): Evaluation {\n    if (this.nextUnrolledStates.some(({evaluation}) => !evaluation)) {\n      throw new Error(\"Some part of the evaluation tree is not completed\");\n    }\n    return this.compilePartialEvaluation({useCached: false});\n  }\n\n  getCompletionProgress(): number {\n    if (this.finished) {\n      return 1;\n    }\n    const completedCount = this.nextUnrolledStates.reduce(\n      (total, current) => total + (current.evaluation ? 1 : (current.evaluator?.getCompletionProgress() ?? 0)), 0);\n    return completedCount / this.nextUnrolledStates.length;\n  }\n\n  compilePartialEvaluation({useCached = true}: {useCached?: boolean} = {}): Evaluation {\n    if (this.evaluation && useCached) {\n      return this.evaluation;\n    }\n    return Evaluation.combineOptions(\n      this.nextUnrolledStates\n      .filter(({evaluator, evaluation}) => evaluator || evaluation)\n      .map(({evaluator, evaluation}) => evaluation ?? evaluator!.compilePartialEvaluation())\n    );\n  }\n}\n","import {Evaluation} from \"./Evaluation\";\nimport {RolledState} from \"./RolledState\";\nimport {RolledStateEvaluator} from \"./RolledStateEvaluator\";\nimport {UnrolledState} from \"./UnrolledState\";\nimport {IStateEvaluator, SearchOptions} from \"./IStateEvaluator\";\n\ninterface NextRolledState {\n  rolledState: RolledState;\n  count: number;\n  evaluator: RolledStateEvaluator | null;\n  evaluation: Evaluation | null;\n}\n\nexport class UnrolledStateEvaluator implements IStateEvaluator<UnrolledState> {\n  state: UnrolledState;\n  nextRolledStates: NextRolledState[] | null;\n  evaluation: Evaluation | null = null;\n  isRoot: boolean;\n\n  static fromUnrolledState(unrolledState: UnrolledState, isRoot: boolean): UnrolledStateEvaluator {\n    const nextRolledStates = unrolledState.getNextRolledStates();\n    return new UnrolledStateEvaluator(\n      unrolledState,\n      nextRolledStates.map(nextRolledState => ({...nextRolledState, evaluator: null, evaluation: null})),\n      isRoot,\n    );\n  }\n\n  static fromUnrolledStateLazy(unrolledState: UnrolledState, isRoot: boolean): UnrolledStateEvaluator {\n    return new UnrolledStateEvaluator(\n      unrolledState,\n      null,\n      isRoot,\n    );\n  }\n\n  static getRemainingDiceCountFromCacheKey(cacheKey: string): number | null {\n    if (cacheKey[0] !== \"S\") {\n      return null;\n    }\n    const [, remainingDiceCountStr] = cacheKey.split(\"r\");\n    const remainingDiceCount = parseInt(remainingDiceCountStr, 10);\n    if (isNaN(remainingDiceCount)) {\n      return null;\n    }\n    return remainingDiceCount;\n  }\n\n  constructor(unrolledState: UnrolledState, nextRolledStates: NextRolledState[] | null, isRoot: boolean) {\n    this.state = unrolledState;\n    this.nextRolledStates = nextRolledStates;\n    this.isRoot = isRoot;\n  }\n\n  get finished(): boolean {\n    return this.evaluation !== null;\n  }\n\n  processAll(options?: SearchOptions): this {\n    while (this.processOne(options)) {\n      //\n    }\n    return this;\n  }\n\n  processOne(options?: SearchOptions): boolean {\n    if (this.finished) {\n      return false;\n    }\n    if (this.nestedProcessOne(options)) {\n      return true;\n    }\n    if (!this.evaluation) {\n      this.evaluation = this.compileEvaluation();\n      if (this.isRoot) {\n        this.setOwnEvaluationCache(options);\n      }\n    }\n    return false;\n  }\n\n  nestedProcessOne(options?: SearchOptions): boolean {\n    const {removeEvaluated = false} = options ?? {};\n    if (this.finished) {\n      return false;\n    }\n    if (!this.nextRolledStates) {\n      if (options?.evaluationCache) {\n        const evaluation = options.evaluationCache.get(this.getCacheKey());\n        if (evaluation) {\n          this.evaluation = evaluation;\n          return false;\n        }\n      }\n      this.nextRolledStates = this.state\n        .getNextRolledStates()\n        .map(nextRolledState => ({...nextRolledState, evaluator: null, evaluation: null}));\n    }\n    for (const nextRolledState of this.nextRolledStates) {\n      if (nextRolledState.evaluation) {\n        continue;\n      }\n      if (!nextRolledState.evaluator) {\n        nextRolledState.evaluator = RolledStateEvaluator.fromRolledState(nextRolledState.rolledState);\n        if (this.useEvaluationCache(nextRolledState, options)) {\n          continue;\n        }\n      }\n      nextRolledState.evaluator.processOne(options);\n      if (nextRolledState.evaluator.evaluation) {\n        nextRolledState.evaluation = nextRolledState.evaluator.evaluation;\n        this.setEvaluationCache(nextRolledState, options);\n        if (removeEvaluated) {\n          nextRolledState.evaluator = null;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  useEvaluationCache(nextRolledState: NextRolledState, options?: SearchOptions): boolean {\n    if (!nextRolledState.evaluator) {\n      return false;\n    }\n    const {removeEvaluated = false, evaluationCache} = options ?? {};\n    const evaluation = evaluationCache?.get(nextRolledState.evaluator.getCacheKey());\n    if (evaluation) {\n      nextRolledState.evaluation = evaluation;\n      if (removeEvaluated) {\n        nextRolledState.evaluator = null;\n      }\n      return true;\n    }\n    return false;\n  }\n\n\n  setEvaluationCache(nextRolledState: NextRolledState, options?: SearchOptions) {\n    if (!nextRolledState.evaluator || !nextRolledState.evaluation) {\n      return;\n    }\n    const {evaluationCache} = options ?? {};\n    if (evaluationCache) {\n      evaluationCache.set(nextRolledState.evaluator.getCacheKey(), nextRolledState.evaluation);\n    }\n  }\n\n  setOwnEvaluationCache(options?: SearchOptions) {\n    if (!this.evaluation) {\n      return;\n    }\n    const {evaluationCache} = options ?? {};\n    if (evaluationCache) {\n      evaluationCache.set(this.getCacheKey(), this.evaluation);\n    }\n  }\n\n  getCacheKey(): string {\n    return [\n      \"S\",\n      `t${this.state.chest.total}`,\n      `c${this.state.chest.uniqueDice().join(\",\")}`,\n      `r${this.state.remainingDiceCount}`,\n    ].join(\"\").replaceAll(/[[\\]]/g, \"\");\n  }\n\n  compileEvaluation(): Evaluation {\n    if (!this.nextRolledStates || this.nextRolledStates.some(({evaluation}) => !evaluation)) {\n      throw new Error(\"Some part of the evaluation tree is not completed\");\n    }\n    return this.compilePartialEvaluation({useCached: false});\n  }\n\n  getCompletionProgress(): number {\n    if (this.finished) {\n      return 1;\n    }\n    if (!this.nextRolledStates) {\n      return 0;\n    }\n    if (!this.nextRolledStates.length) {\n      return 1;\n    }\n    const completedCount = this.nextRolledStates.reduce(\n      (total, current) => total + (current.evaluation ? 1 : (current.evaluator?.getCompletionProgress() ?? 0)), 0);\n    return completedCount / this.nextRolledStates.length;\n  }\n\n  compilePartialEvaluation({useCached = true}: {useCached?: boolean} = {}): Evaluation {\n    if (this.evaluation && useCached) {\n      return this.evaluation;\n    }\n    if (!this.nextRolledStates) {\n      return Evaluation.empty();\n    }\n    if (!this.nextRolledStates.length) {\n      return Evaluation.fromTotal(this.state.total);\n    }\n    const nextRolledStatesWithEvaluation = this.nextRolledStates\n      .filter(({evaluator, evaluation}) => evaluator || evaluation);\n    const totalCount = nextRolledStatesWithEvaluation.reduce(\n      (total, current) => total + current.count, 0);\n    const combined = Evaluation.combineProbabilities(\n      nextRolledStatesWithEvaluation\n      .map(({evaluator, evaluation, count}) => ({\n        evaluation: evaluation ?? evaluator!.compilePartialEvaluation(),\n        ratio: count / totalCount,\n      }))\n    );\n    // Because we can choose to stop, the current total has 100% chance of happening, if it's our target\n    combined.exactResultOccurrences.set(this.state.total, 1);\n    return combined;\n  }\n}\n","import {UnrolledStateEvaluator} from \"./UnrolledStateEvaluator\";\nimport {RolledStateEvaluator} from \"./RolledStateEvaluator\";\nimport {State} from \"./State\";\nimport {Evaluation} from \"./Evaluation\";\nimport {SearchOptions} from \"./IStateEvaluator\";\n\nexport type StateEvaluator = UnrolledStateEvaluator | RolledStateEvaluator;\nexport class StateEvaluatorHelper {\n  static evaluatorFromStateLazy(state: State, isRoot: boolean): StateEvaluator {\n    switch (state.type) {\n      case \"unrolled\":\n        return UnrolledStateEvaluator.fromUnrolledStateLazy(state, isRoot);\n      case \"rolled\":\n        return RolledStateEvaluator.fromRolledState(state);\n      default:\n        throw new Error(\"Unknown state type\");\n    }\n  }\n\n  static getStateCacheKey(state: State): string {\n    return this.evaluatorFromStateLazy(state, true).getCacheKey();\n  }\n\n  static processAllFromState(state: State, options?: SearchOptions): Evaluation {\n    const evaluator = this.evaluatorFromStateLazy(state, true);\n    return evaluator.processAll(options).evaluation!;\n  }\n\n  static getRemainingDiceCountFromCacheKey(cacheKey: string): number | null {\n    return (\n      UnrolledStateEvaluator.getRemainingDiceCountFromCacheKey(cacheKey)\n      ?? RolledStateEvaluator.getRemainingDiceCountFromCacheKey(cacheKey)\n    );\n  }\n}\n","import {CompressedSerialisedEvaluation, Evaluation, SerialisedEvaluation} from \"./Evaluation\";\nimport {CompressedSerialisedResults, SerialisationOptions, SerialisedResults} from \"./Results\";\nimport {StateEvaluatorHelper} from \"./StateEvaluator\";\n\nexport interface EvaluationCacheStats {\n  hitCount: number,\n  missCount: number,\n  entryCount: number,\n}\n\nexport type SerialisedEvaluationCache = [string, SerialisedResults, SerialisedResults, SerialisedResults, number][];\nexport type CompressedSerialisedEvaluationCache = [string, CompressedSerialisedResults, SerialisedResults, CompressedSerialisedResults, number][];\n\nexport class EvaluationCache {\n  cache: Map<string, Evaluation> = new Map();\n  hitCount: number = 0;\n  missCount: number = 0;\n\n  static deserialise(serialised: SerialisedEvaluationCache | CompressedSerialisedEvaluationCache, options: SerialisationOptions): EvaluationCache {\n    const cache = new EvaluationCache();\n    for (const [key, minimumResultOccurrencesEntries, exactResultOccurrencesEntries, expectedValueOfAtLeastEntries, expectedValue] of serialised) {\n      cache.set(key, Evaluation.deserialise({\n        minimumResultOccurrencesEntries,\n        exactResultOccurrencesEntries,\n        expectedValueOfAtLeastEntries: expectedValueOfAtLeastEntries,\n        expectedValue: expectedValue,\n      } as SerialisedEvaluation | CompressedSerialisedEvaluation, options));\n    }\n    return cache;\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key);\n  }\n\n  get(key: string): Evaluation | undefined {\n    if (this.cache.has(key)) {\n      this.hitCount++;\n    } else {\n      this.missCount++;\n    }\n    return this.cache.get(key);\n  }\n\n  set(key: string, evaluation: Evaluation) {\n    this.cache.set(key, evaluation);\n  }\n\n  get size(): number {\n    return this.cache.size;\n  }\n\n  getStats(): EvaluationCacheStats {\n    return {\n      hitCount: this.hitCount,\n      missCount: this.missCount,\n      entryCount: this.cache.size,\n    };\n  }\n\n  serialise(options: SerialisationOptions): SerialisedEvaluationCache | CompressedSerialisedEvaluationCache {\n    let entries = Array.from(this.cache.entries());\n    if (options.sparse) {\n      entries = entries.filter(([key]) => {\n        const remainingDiceCount: number | null = StateEvaluatorHelper.getRemainingDiceCountFromCacheKey(key);\n        if (remainingDiceCount === null) {\n          return false;\n        }\n        return remainingDiceCount > 4;\n      });\n    }\n    return entries.map(\n      ([key, evaluation]) => {\n        const serialisedEvaluation = evaluation.serialise(options) as SerialisedEvaluation;\n        return [\n          key,\n          serialisedEvaluation.minimumResultOccurrencesEntries,\n          serialisedEvaluation.exactResultOccurrencesEntries,\n          serialisedEvaluation.expectedValueOfAtLeastEntries,\n          serialisedEvaluation.expectedValue,\n        ];\n      });\n  }\n}\n","import { Chest } from \"./Chest\";\nimport { DiceRoll } from \"./DiceRoll\";\nimport { RolledState } from \"./RolledState\";\nimport { RollResult } from \"./RollResult\";\nimport {IState} from \"./IState\";\n\nexport interface SerialisedUnrolledState {\n  chestDice: RollResult[],\n  remainingDiceCount: number,\n}\n\ntype UnrolledStateType = \"unrolled\";\n\nexport class UnrolledState implements IState {\n  type: UnrolledStateType = \"unrolled\";\n  chest: Chest;\n  remainingDiceCount: number;\n\n  static initial(): UnrolledState {\n    return new UnrolledState(Chest.initial(), 8);\n  }\n\n  static empty(): UnrolledState {\n    return new UnrolledState(Chest.initial(), 0);\n  }\n\n  static fromDice(dice: RollResult[], remainingDiceCount: number): UnrolledState {\n    return new UnrolledState(Chest.fromDice(dice), remainingDiceCount);\n  }\n\n  static deserialise(serialised: SerialisedUnrolledState): UnrolledState {\n    return UnrolledState.fromDice(serialised.chestDice, serialised.remainingDiceCount);\n  }\n\n  constructor(chest: Chest, remainingDiceCount: number) {\n    this.chest = chest;\n    this.remainingDiceCount = remainingDiceCount;\n  }\n\n  equals(other: UnrolledState): boolean {\n    if (this === other) {\n      return true;\n    }\n    return (\n      this.remainingDiceCount === other.remainingDiceCount\n      && this.chest.equals(other.chest)\n    )\n  }\n\n  get unrolledState(): this {\n    return this;\n  }\n\n  get pickedDice(): DiceRoll {\n    return this.chest.diceCounts.copy();\n  }\n\n  get rolledDice(): null {\n    return null;\n  }\n\n  get totalDiceCount(): number {\n    return this.chest.diceCount + this.remainingDiceCount;\n  }\n\n  get selectedDiceCount(): number {\n    return this.chest.diceCount;\n  }\n\n  get runningTotal(): number {\n    return this.chest.total;\n  }\n\n  get total(): number {\n    if (this.chest.hasWorms) {\n      return this.chest.total;\n    } else {\n      return 0;\n    }\n  }\n\n  getNextRolledStates(): {rolledState: RolledState, count: number}[] {\n    return DiceRoll.getNextRolls(this.remainingDiceCount).map(({diceRoll, count}) => ({\n      rolledState: this.withRoll(diceRoll), \n      count,\n    }));\n  }\n\n  withRoll(diceRoll: DiceRoll): RolledState {\n    return new RolledState(this, diceRoll);\n  }\n\n  withRandomRoll(): RolledState {\n    if (!this.remainingDiceCount) {\n      throw new Error(\"There are no remaining dice to roll\");\n    }\n    return this.withRoll(DiceRoll.random(this.remainingDiceCount));\n  }\n\n  withPick(pickedRoll: RollResult, pickedCount: number): UnrolledState {\n    if (!this.chest.canAdd(pickedRoll)) {\n      throw new Error(\"Cannot pick same die again\");\n    }\n    if (pickedCount > this.remainingDiceCount) {\n      throw new Error(\"Cannot pick that many dice\");\n    }\n    return new UnrolledState(this.chest.add(pickedRoll, pickedCount), this.remainingDiceCount - pickedCount);\n  }\n\n  canAdd(roll: RollResult): boolean {\n    return this.chest.canAdd(roll);\n  }\n\n  add(roll: RollResult, diceCount: number): UnrolledState {\n    return new UnrolledState(this.chest.add(roll, diceCount), this.remainingDiceCount - diceCount);\n  }\n\n  finished(): UnrolledState {\n    return new UnrolledState(this.chest, 0);\n  }\n\n  serialise(): SerialisedUnrolledState {\n    return {\n      chestDice: this.chest.dice,\n      remainingDiceCount: this.remainingDiceCount,\n    };\n  }\n}\n","import {DiceRoll} from \"./DiceRoll\";\nimport {RollResult} from \"./RollResult\";\nimport {UnrolledState} from \"./UnrolledState\";\nimport {IState} from \"./IState\";\n\nexport interface SerialisedRolledState {\n  chestDice: RollResult[],\n  rolledDice: RollResult[],\n}\n\ntype RolledStateType = \"rolled\";\n\nexport class RolledState implements IState {\n  type: RolledStateType = \"rolled\";\n  unrolledState: UnrolledState;\n  diceRoll: DiceRoll;\n\n  static fromDice(chestDice: RollResult[], rolledDice: RollResult[]): RolledState {\n    return new RolledState(UnrolledState.fromDice(chestDice, rolledDice.length), DiceRoll.fromDice(rolledDice));\n  }\n\n  static deserialise(serialised: SerialisedRolledState): RolledState {\n    return RolledState.fromDice(serialised.chestDice, serialised.rolledDice);\n  }\n\n  constructor(unrolledState: UnrolledState, diceRoll: DiceRoll) {\n    this.unrolledState = unrolledState;\n    this.diceRoll = diceRoll;\n  }\n\n  get pickedDice(): DiceRoll {\n    return this.unrolledState.pickedDice;\n  }\n\n  get rolledDice(): DiceRoll {\n    return this.diceRoll;\n  }\n\n  get totalDiceCount(): number {\n    return this.unrolledState.totalDiceCount;\n  }\n\n  get selectedDiceCount(): number {\n    return this.unrolledState.selectedDiceCount + this.diceRoll.diceCount;\n  }\n\n  get remainingDiceCount(): number {\n    return this.totalDiceCount - this.selectedDiceCount;\n  }\n\n  get runningTotal(): number {\n    return this.unrolledState.runningTotal;\n  }\n\n  get total(): number {\n    return this.unrolledState.total;\n  }\n\n  getNextUnrolledStates(): UnrolledState[] {\n    return this.getNextUnrolledStatesAndPickedRolls().map(({state}) => state);\n  }\n\n  getNextUnrolledStatesAndPickedRolls(): {state: UnrolledState, pickedRoll: RollResult | null, pickedCount: number | null}[] {\n    const nextUnrolledStates = Array.from(this.diceRoll.entries())\n      .filter(([roll]) => this.unrolledState.canAdd(roll))\n      .map(([roll, diceCount]) => ({state: this.unrolledState.add(roll, diceCount), pickedRoll: roll, pickedCount: diceCount}));\n    if (!nextUnrolledStates.length) {\n      return [{state: this.unrolledState.finished(), pickedRoll: null, pickedCount: null}];\n    }\n    return nextUnrolledStates;\n  }\n\n  pick(pickedRoll: RollResult): UnrolledState {\n    if (!this.diceRoll.has(pickedRoll)) {\n      throw new Error(\"Face was not rolled\");\n    }\n    return this.unrolledState.add(pickedRoll, this.diceRoll.get(pickedRoll));\n  }\n\n  serialise(): SerialisedRolledState {\n    return {\n      chestDice: this.unrolledState.chest.dice,\n      rolledDice: this.rolledDice.dice,\n    };\n  }\n}\n","import * as worms from \"./worms\";\nimport {OnCacheFetchingProgress} from \"./RemoteSearch\";\n\nexport class EvaluationCacheCache {\n  evaluationCacheUrlMap: Map<number, string> = new Map([\n    [5, \"evaluation-cache-5-dice.json\"],\n    [6, \"evaluation-cache-6-dice.json\"],\n    [7, \"evaluation-cache-7-dice.json\"],\n    [8, \"evaluation-cache-8-dice.json\"],\n  ]);\n  hasFetchedEvaluationCacheMap: Map<number, boolean> = new Map();\n  // Reusable evaluation caches\n  evaluationCacheMap: Map<number, worms.EvaluationCache> = new Map();\n  onCacheFetchingProgress: OnCacheFetchingProgress | null;\n\n  constructor(onCacheFetchingProgress: OnCacheFetchingProgress | undefined | null = null) {\n    this.onCacheFetchingProgress = onCacheFetchingProgress ?? null;\n  }\n\n  async get(diceCount: number): Promise<worms.EvaluationCache> {\n    if (this.shouldFetchEvaluationCache(diceCount)) {\n      this.evaluationCacheMap.set(diceCount, (\n        await this.fetchEvaluationCache(diceCount)\n        ?? this.evaluationCacheMap.get(diceCount)\n        ?? new worms.EvaluationCache()\n      ));\n    } else if (this.shouldSetEmptyEvaluationCache(diceCount)) {\n      this.evaluationCacheMap.set(diceCount, new worms.EvaluationCache());\n    }\n    return this.evaluationCacheMap.get(diceCount)!;\n  }\n\n  getSync(diceCount: number, callback: (evaluationCache: worms.EvaluationCache) => void): worms.EvaluationCache {\n    if (this.shouldFetchEvaluationCache(diceCount)) {\n      (async () => {\n        callback(await this.get(diceCount));\n      })();\n    }\n    if (this.shouldSetEmptyEvaluationCache(diceCount)) {\n      this.evaluationCacheMap.set(diceCount, new worms.EvaluationCache());\n    }\n    return this.evaluationCacheMap.get(diceCount)!;\n  }\n\n  shouldFetchEvaluationCache(diceCount: number): boolean {\n    return (\n      !this.evaluationCacheMap.get(diceCount)?.size\n      && this.evaluationCacheUrlMap.has(diceCount)\n      && !(this.hasFetchedEvaluationCacheMap.get(diceCount) ?? false)\n    );\n  }\n\n  shouldSetEmptyEvaluationCache(diceCount: number): boolean {\n    return !this.evaluationCacheMap.has(diceCount);\n  }\n\n  async fetchEvaluationCache(diceCount: number): Promise<worms.EvaluationCache | null> {\n    const evaluationCacheUrl = this.evaluationCacheUrlMap.get(diceCount);\n    if (!evaluationCacheUrl) {\n      return null;\n    }\n    const response = await fetch(`${process.env.PUBLIC_URL}/${evaluationCacheUrl}`);\n    this.onCacheFetchingProgress?.(diceCount, \"fetching\");\n    let evaluationCache;\n    try {\n      evaluationCache = worms.EvaluationCache.deserialise(JSON.parse(await response.text()), {rounded: true, compressed: true, sparse: true});\n    } catch (e) {\n      this.onCacheFetchingProgress?.(diceCount, \"failure\");\n      console.error(\"File was not a valid cache file\");\n      return null;\n    }\n    this.hasFetchedEvaluationCacheMap.set(diceCount, true);\n    this.onCacheFetchingProgress?.(diceCount, \"success\");\n    return evaluationCache;\n  }\n\n  clear(diceCount: number): worms.EvaluationCache {\n    this.evaluationCacheMap.set(diceCount, new worms.EvaluationCache());\n    return this.evaluationCacheMap.get(diceCount)!;\n  }\n\n  set(diceCount: number, evaluationCache: worms.EvaluationCache) {\n    this.evaluationCacheMap.set(diceCount, evaluationCache);\n  }\n}\n","import {CacheFetchingStatus, SearchRequestMessage, SearchResponseMessage} from \"./RemoteSearch\";\nimport * as worms from \"./worms\";\nimport {EvaluationCacheCache} from \"./EvaluationCacheCache\";\nimport {Evaluation, SerialisedEvaluation, StateEvaluator, StateEvaluatorHelper} from \"./worms\";\nimport _ from \"underscore\";\n\ninterface InstanceInfo {\n  id: number,\n  stateEvaluator: worms.StateEvaluator,\n  searching: boolean,\n  evaluationCache: worms.EvaluationCache,\n}\n\nclass SearchWorker {\n  instancesById: Map<number, InstanceInfo> = new Map();\n  worker: Worker;\n  onCacheFetchingProgress = (diceCount: number, status: CacheFetchingStatus) => {\n    const matchingInstances = Array.from(this.instancesById.values())\n      .filter(instance => instance.stateEvaluator.state.totalDiceCount === diceCount);\n    for (const instance of matchingInstances) {\n      this.postMessage({\n        type: \"cache-fetching-progress\",\n        id: instance.id,\n        diceCount,\n        status,\n      });\n    }\n  };\n  evaluationCacheCache: EvaluationCacheCache = new EvaluationCacheCache(this.onCacheFetchingProgress);\n\n  static default(): SearchWorker {\n    return new SearchWorker(self as unknown as Worker);\n  }\n\n  constructor(worker: Worker) {\n    this.worker = worker;\n    this.worker.onmessage = this.onMessage;\n  }\n\n  private postMessage(message: SearchResponseMessage) {\n    this.worker.postMessage(message);\n  }\n\n  postResult(instanceId: number) {\n    if (!this.instancesById.has(instanceId)) {\n      return;\n    }\n    const instance = this.instancesById.get(instanceId)!;\n    const {stateEvaluator, searching, evaluationCache} = instance;\n    const progress = stateEvaluator.getCompletionProgress();\n    const serialisedEvaluation = stateEvaluator.compilePartialEvaluation().serialise({}) as SerialisedEvaluation;\n    this.postMessage({\n      type: \"result\",\n      id: instanceId,\n      progress,\n      searching,\n      searchFinished: progress === 1,\n      evaluation: serialisedEvaluation,\n      preRollEvaluation: (\n        instance.stateEvaluator.state.type === \"unrolled\"\n          ? serialisedEvaluation\n          : this.getEvaluation(instance, instance.stateEvaluator.state.unrolledState).serialise({}) as SerialisedEvaluation\n      ),\n      dicePickEvaluations: stateEvaluator.state.type === \"unrolled\" ? null : (\n        stateEvaluator.state.getNextUnrolledStatesAndPickedRolls()\n        .filter(({pickedRoll}) => pickedRoll !== null)\n        .map(({state, pickedRoll, pickedCount}) => {\n          return {\n            pickedRoll: pickedRoll!,\n            pickedCount: pickedCount!,\n            evaluation: this.getEvaluation(instance, state).serialise({}) as SerialisedEvaluation,\n            total: state.runningTotal,\n          };\n        })\n      ),\n      cacheStats: evaluationCache.getStats(),\n    });\n  }\n\n  onMessage = ({data}: MessageEvent<SearchRequestMessage>) => {\n    switch (data.type) {\n      case \"set-state\":\n        switch (data.stateType) {\n          case \"unrolled\":\n            this.onSetUnrolledState(data.id, worms.UnrolledState.deserialise(data.state));\n            break;\n          case \"rolled\":\n            this.onSetRolledState(data.id, worms.RolledState.deserialise(data.state));\n            break;\n          default:\n            throw new Error(\"Unknown state type\");\n        }\n        break;\n      case \"step\":\n        this.onStep(data.id);\n        break;\n      case \"start\":\n        this.onStart(data.id);\n        break;\n      case \"stop\":\n        this.onStop(data.id);\n        break;\n      case \"remove\":\n        this.onRemove(data.id);\n        break;\n      case \"download-evaluation-cache\":\n        this.onDownloadEvaluationCache(data.id);\n        break;\n      case \"load-evaluation-cache\":\n        this.onLoadEvaluationCache(data.id, data.jsonSerialised);\n        break;\n      case \"clear-evaluation-cache\":\n        this.onClearEvaluationCache(data.id);\n        break;\n      case \"dice-comparison\":\n        this.requestDiceComparison(data.id, worms.UnrolledState.deserialise(data.unrolledState), data.firstDie, data.secondDie);\n        break;\n    }\n  };\n\n  onSetUnrolledState(instanceId: number, unrolledState: worms.UnrolledState) {\n    this.setStateEvaluator(instanceId, worms.UnrolledStateEvaluator.fromUnrolledStateLazy(unrolledState, true));\n  }\n\n  onSetRolledState(instanceId: number, rolledState: worms.RolledState) {\n    this.setStateEvaluator(instanceId, worms.RolledStateEvaluator.fromRolledState(rolledState));\n  }\n\n  setStateEvaluator(instanceId: number, stateEvaluator: StateEvaluator) {\n    this.onStop(instanceId);\n    const instance = {\n      id: instanceId,\n      stateEvaluator,\n      searching: false,\n      evaluationCache: this.evaluationCacheCache.getSync(stateEvaluator.state.totalDiceCount, evaluationCache => {\n        const instance = this.instancesById.get(instanceId);\n        if (!instance) {\n          return;\n        }\n        this.setEvaluationCache(instance, evaluationCache);\n      }),\n    };\n    this.instancesById.set(instanceId, instance);\n    this.setEvaluationCache(instance, instance.evaluationCache);\n    if (!instance.stateEvaluator.finished && !instance.searching && instance.stateEvaluator.state.remainingDiceCount <= 4) {\n      this.onStart(instance.id);\n    }\n  }\n\n  getEvaluation(instance: InstanceInfo, state: worms.State): Evaluation {\n    const cacheKey = StateEvaluatorHelper.getStateCacheKey(state);\n    if (!instance.evaluationCache.has(cacheKey) && state.remainingDiceCount <= 4) {\n      StateEvaluatorHelper.processAllFromState(state, {evaluationCache: instance.evaluationCache});\n    }\n\n    return instance.evaluationCache.get(cacheKey) ?? Evaluation.empty();\n  }\n\n  onStep(instanceId: number) {\n    if (!this.instancesById.has(instanceId)) {\n      return;\n    }\n    const {stateEvaluator, evaluationCache} = this.instancesById.get(instanceId)!;\n    stateEvaluator.processOne({removeEvaluated: true, evaluationCache});\n    this.postResult(instanceId);\n  }\n\n  onStart(instanceId: number) {\n    this.onStop(instanceId);\n    const iterator = this.makeSearch(instanceId);\n    if (!iterator) {\n      return;\n    }\n    self.setTimeout(iterator, 0);\n  }\n\n  onDownloadEvaluationCache(instanceId: number) {\n    if (!this.instancesById.has(instanceId)) {\n      return;\n    }\n    const {evaluationCache} = this.instancesById.get(instanceId)!;\n    const bytes = new TextEncoder().encode(JSON.stringify(evaluationCache.serialise({rounded: true, compressed: true, sparse: true})));\n    const blob = new Blob([bytes], {\n      type: \"application/json;charset=utf-8\",\n    });\n    const url = URL.createObjectURL(blob);\n    self.postMessage({\n      type: \"evaluation-cache-link\",\n      id: instanceId,\n      link: url,\n    });\n  }\n\n  onLoadEvaluationCache(instanceId: number, jsonSerialised: string) {\n    if (!this.instancesById.has(instanceId)) {\n      return;\n    }\n    const instance = this.instancesById.get(instanceId)!;\n    let evaluationCache;\n    try {\n      evaluationCache = worms.EvaluationCache.deserialise(JSON.parse(jsonSerialised), {rounded: true, compressed: true, sparse: true});\n    } catch (e) {\n      console.error(\"File was not a valid cache file\");\n      return;\n    }\n    this.setEvaluationCache(instance, evaluationCache);\n  }\n\n  setEvaluationCache(instance: InstanceInfo, evaluationCache: worms.EvaluationCache) {\n    this.evaluationCacheCache.set(instance.stateEvaluator.state.totalDiceCount, evaluationCache);\n    instance.evaluationCache = evaluationCache;\n    const evaluator = instance.stateEvaluator;\n    const cacheKey = evaluator.getCacheKey();\n    if (!evaluator.finished && instance.evaluationCache.has(cacheKey)) {\n      evaluator.evaluation = instance.evaluationCache.get(cacheKey)!;\n      instance.searching = true;\n    }\n    this.postResult(instance.id);\n  }\n\n  onClearEvaluationCache(instanceId: number) {\n    if (!this.instancesById.has(instanceId)) {\n      return;\n    }\n    const instance = this.instancesById.get(instanceId)!;\n    instance.evaluationCache = this.evaluationCacheCache\n      .clear(instance.stateEvaluator.state.totalDiceCount);\n    this.postResult(instanceId);\n  }\n\n  makeSearch(instanceId: number, reportInterval: number = 1000): (() => void) | null {\n    if (!this.instancesById.has(instanceId)) {\n      return null;\n    }\n    const instanceInfo = this.instancesById.get(instanceId)!;\n    instanceInfo.searching = true;\n    const iterator = () => {\n      const startTime = new Date();\n      while (instanceInfo.searching && !instanceInfo.stateEvaluator.finished) {\n        instanceInfo.stateEvaluator.processOne({removeEvaluated: true, evaluationCache: instanceInfo.evaluationCache});\n        const endTime = new Date();\n        if ((endTime.valueOf() - startTime.valueOf()) >= reportInterval) {\n          self.setTimeout(iterator, 0);\n          break;\n        }\n      }\n      this.postResult(instanceId);\n    };\n    return iterator;\n  }\n\n  onStop(instanceId: number) {\n    if (!this.instancesById.has(instanceId)) {\n      return;\n    }\n    this.instancesById.get(instanceId)!.searching = false;\n    this.postResult(instanceId);\n  }\n\n  onRemove(instanceId: number) {\n    if (!this.instancesById.has(instanceId)) {\n      return;\n    }\n    this.instancesById.get(instanceId)!.searching = false;\n    this.postResult(instanceId);\n    this.instancesById.delete(instanceId);\n  }\n\n  private requestDiceComparison(id: number, unrolledState: worms.UnrolledState, firstDie: worms.RollResult, secondDie: worms.RollResult) {\n    if (!this.instancesById.has(id)) {\n      return;\n    }\n    const instance = this.instancesById.get(id)!;\n    this.postMessage({\n      type: \"dice-comparison\",\n      id,\n      diceComparisonEvaluationsInfo: {\n        unrolledState: unrolledState.serialise(),\n        firstDie,\n        secondDie,\n        firstEvaluations: new Map(_.range(1, unrolledState.remainingDiceCount).map(\n          firstDiceCount => [firstDiceCount, this.getEvaluation(instance, unrolledState.withPick(firstDie, firstDiceCount)).serialise({}) as SerialisedEvaluation],\n        )),\n        secondEvaluations: new Map(_.range(1, unrolledState.remainingDiceCount).map(\n          secondDiceCount => [secondDiceCount, this.getEvaluation(instance, unrolledState.withPick(secondDie, secondDiceCount)).serialise({}) as SerialisedEvaluation],\n        )),\n      },\n    });\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst worker = SearchWorker.default();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [871], function() { return __webpack_require__(3956); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"6b4d62fe\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/probable-worms/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t956: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkprobable_worms\"] = self[\"webpackChunkprobable_worms\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(871).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["Worm","rollResults","ValueMap","Map","DiceRoll","items","_classCallCheck","counts","key","total","this","JSON","stringify","Array","from","entries","sort","reduce","_ref","_ref2","_slicedToArray","roll","count","get","_createClass","value","other","concat","_toConsumableArray","_this$counts$get","has","keys","size","values","current","map","_ref3","_ref4","_","flat","lhs","rhs","indexOf","copy","replace","set","delete","diceCount","_step","diceRoll","remainingDiceCount","_iterator","_createForOfIteratorHelper","s","n","done","rollCount","Math","min","err","e","f","_this","filter","face","_this2","faces","_this3","some","_step2","_iterator2","dice","Object","group","length","fromDice","_step3","diceRollInfoByKey","_iterator3","iterateDiceRolls","_regeneratorRuntime","mark","_marked","addLayer","_1","_iterator6","_step6","item","wrap","_context2","prev","next","lists","layer","_iterator4","_step4","list","_iterator5","_step5","newItem","_context","t0","finish","t1","stop","abrupt","Chest","diceCounts","hasWorms","equals","canAdd","Error","adding","fromDiceRoll","replacing","Results","_step$value","result","_value$constructor","isNaN","parseFloat","toFixed","constructor","name","options","serialised","rounded","ratio","round","compressed","_ref5","_ref6","_ref9","_ref10","rollTotal","max","_total","lastMin","lastMax","lastRatio","slice","expandedTriples","_ref11","_ref12","_ref13","_ref14","Evaluation","minimumResultOccurrences","exactResultOccurrences","expectedValueOfAtLeast","expectedValue","parseInt","minimumResultOccurrencesEntries","serialise","exactResultOccurrencesEntries","expectedValueOfAtLeastEntries","combined","empty","maxExpectedValue","evaluation","_step2$value","_step3$value","_step4$value","_step5$value","evaluationRatio","_step6$value","_step7","_iterator7","_step7$value","_step8","_iterator8","_step8$value","_step9","_iterator9","minTotal","deserialise","RolledStateEvaluator","rolledState","nextUnrolledStates","state","processOne","finished","nestedProcessOne","compileEvaluation","_ref$removeEvaluated","removeEvaluated","nextUnrolledState","evaluator","UnrolledStateEvaluator","fromUnrolledState","unrolledState","useEvaluationCache","setEvaluationCache","_ref2$removeEvaluated","evaluationCache","getCacheKey","chest","uniqueDice","join","replaceAll","compilePartialEvaluation","useCached","_current$evaluator$ge","_current$evaluator","getCompletionProgress","_ref5$useCached","arguments","undefined","combineOptions","_ref7","getNextUnrolledStates","cacheKey","_cacheKey$split","split","itemStr","index","nextRolledStates","isRoot","setOwnEvaluationCache","getNextRolledStates","nextRolledState","_objectSpread","fromRolledState","_ref6$useCached","fromTotal","nextRolledStatesWithEvaluation","totalCount","combineProbabilities","_ref8","remainingDiceCountStr","StateEvaluatorHelper","type","fromUnrolledStateLazy","evaluatorFromStateLazy","processAll","_UnrolledStateEvaluat","getRemainingDiceCountFromCacheKey","EvaluationCache","cache","hitCount","missCount","entryCount","sparse","serialisedEvaluation","UnrolledState","getNextRolls","withRoll","RolledState","random","pickedRoll","pickedCount","add","chestDice","initial","pickedDice","totalDiceCount","selectedDiceCount","runningTotal","getNextUnrolledStatesAndPickedRolls","rolledDice","EvaluationCacheCache","onCacheFetchingProgress","evaluationCacheUrlMap","hasFetchedEvaluationCacheMap","evaluationCacheMap","_get","_asyncToGenerator","_callee","_yield$this$fetchEval","shouldFetchEvaluationCache","fetchEvaluationCache","t4","sent","t3","t5","t6","t2","t7","worms","t8","call","shouldSetEmptyEvaluationCache","_x","apply","callback","_callee2","_this$evaluationCache","_this$hasFetchedEvalu","_fetchEvaluationCache","_callee3","_this$onCacheFetching","_this$onCacheFetching3","evaluationCacheUrl","response","_this$onCacheFetching2","_context3","fetch","process","text","parse","console","error","_x2","SearchWorker","worker","instancesById","status","matchingInstances","instance","stateEvaluator","postMessage","id","evaluationCacheCache","onMessage","data","stateType","onSetUnrolledState","onSetRolledState","onStep","onStart","onStop","onRemove","onDownloadEvaluationCache","onLoadEvaluationCache","jsonSerialised","onClearEvaluationCache","requestDiceComparison","firstDie","secondDie","onmessage","message","instanceId","searching","progress","searchFinished","preRollEvaluation","getEvaluation","dicePickEvaluations","cacheStats","getStats","setStateEvaluator","getSync","_instance$evaluationC","getStateCacheKey","processAllFromState","postResult","iterator","makeSearch","self","setTimeout","bytes","TextEncoder","encode","blob","Blob","url","URL","createObjectURL","link","clear","_this4","reportInterval","instanceInfo","startTime","Date","valueOf","_this5","diceComparisonEvaluationsInfo","firstEvaluations","firstDiceCount","withPick","secondEvaluations","secondDiceCount","default","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","every","splice","r","d","definition","o","defineProperty","enumerable","chunkId","Promise","all","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","push","bind","moreModules","runtime","pop","then"],"sourceRoot":""}